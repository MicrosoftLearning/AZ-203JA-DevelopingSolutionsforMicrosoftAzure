---
lab:
    title: 'ラボ: Azure のサービスを使用して多層ソリューションを作成する'
    module: 'モジュール 6: 接続して Azure を使用する、サード パーティのサービス'
---

# ラボ: Azure のサービスを使用した多層ソリューションの作成
# 受講者ラボ マニュアル

## ラボ シナリオ

お客様の会社は、ソリューションの幅広いユース ケースで MicrosoftAzure Search の採用および使用に成功しました。最新のソリューションでは、お客様の会社が Azure Storage テーブルにデータを格納し、Azure Search を使用してそのテーブルにインデックスを付ける必要があります。これを実現するには、最小限のコードで API を構築します。このソリューションには、主に 2 つの要件があります。まず、REST クエリを発行している開発者は、Azure Search がバックグラウンドで使用されていることに関する詳細を認識していないはずです。次に、開発者はシンプルな REST クエリを使用してテーブルに新しいレコードを追加できる必要があります。Azure Search、Azure API Management 、および Azure Logic Apps を使用して、これらの要件をすべて満たす最小限のコード ソリューションを構築することにしました。

## 目的

このモジュールを修了すると、次のことが可能になります：

-   Azure Search アカウントの作成

-   Azure Search インデックスを手動で作成

-   データ ソースからデータを自動的に解析するインデクサを作成。

-   API Management アカウントの作成

-   ヘッダー置換とペイロード操作を使用して、別の Azure Services のプロキシとして API を構成します。

-   Logic アプリ リソースの作成

-   HTTP 要求によってトリガーされるワークフローを構成する。

## ラボのセットアップ

-   **予想時間**：105 分

## 指示

### 開始する前に

#### ラボの仮想マシンへのサインイン

次の認証情報を使用して、**Windows 10** 仮想マシンにサインインしていることを確認します。

-   **ユーザー名**： Admin

-   **パスワード**: Pa55w.rd

#### インストールされたアプリケーションの検討

**Windows 10** デスクトップの下部にあるタスク バーを確認します。タスク バーには、このラボで使用するアプリケーションのアイコンが含まれています。
    
-   Microsoft Edge

-   エクスプローラ

-   Azure Storage Explorer をインストールする

#### 練習用ファイルをダウンロードする

1.  タスク バーで、**Windows PowerShell** アイコンを選択します。

1.  PowerShell コマンド プロンプトで、現在の作業ディレクトリを **Allfiles (F):\\** パスに変更します。

    ```
    cd F:
    ```

1.  コマンド プロンプト内で次のコマンドを入力し、Enter キーを押して、GitHub でホストされている **microsoftlearning/AZ-203-DevelopingSolutionsforMicrosoftAzure** プロジェクトを  **Allfiles (F):\\* ドライブにクローンします。

    ```
    git clone --depth 1 --no-checkout https://github.com/microsoftlearning/AZ-203-DevelopingSolutionsForMicrosoftAzure .
    ```

1.  コマンド プロンプト内で次のコマンドを入力し、**Enter** キーを押 して、**AZ-203T06** ラボを完了するために必要なラボ ファイルをチェックアウトします。

    ```
    git checkout master -- Allfiles/*
    ```

1.  現在実行中の **Windows PowerShell** コマンド プロンプト アプリケーションを閉じます。

### エクササイズ 1: ポータルで Azure Search Serviceを作成する

#### タスク 1: Azure portal を開く

1.  [**Azure portal**](https://portal.azure.com) (portal.azure.com) にサインインします。

1.  Azure portalに初めてサインインする場合は、ポータルのツアーを提供するダイアログ ボックスが表示されます。ツアーをスキップするには、**開始**を選択します。

#### タスク 2: API Management リソースの作成

> Azureポータルから、以下の詳細を使用して新しい **API Management アカウント**を作成します。

  - **既存のリソース グループ**: MultiTierService

  - **名前**: prodapi\[小文字で名前を指定\]

  - **場所**: 米国東部

  - **組織名**: Contoso

  - **価格層：**開発者 (SLA なし)

> **注記**：このラボを進める前に、Azure が API Management アカウントの作成を完了するのを待ちます。アカウントの作成時に通知が届きます。通常、API Management サービスの作成には 20 、 30 分かかります。

#### タスク 3: Azure Search アカウントを作成する

1.  次の詳細を含む新しい **Azure Search** インスタンスを作成します。
    
      - **URL**: prodsearch\[小文字で名前を指定\]
    
      - **新しいリソースグループ**: MultiTierService
    
      - **場所**：米国東部
    
      - **価格層：**Basic

        > **注意**: Azure がAzure Search アカウントの作成を完了するのを待ってから、ラボを進みます。Azure Search アカウントの作成時に通知が届きます。

1.  新しく作成した **Azure Search** インスタンスの**キー**ブレードにアクセスします。

1.  **検索キー**の 1 つを記録します。これらの値は、この演習の後半で使用します。

#### タスク 4: インデックスの作成

1.  この実習ラボで前に作成した **prodsearch\** 検索サービスにアクセスします。

1.  **検索サービス** ブレードで、**インデックスの追加 **を選択します。

1.  以下の詳細で新しいインデックスを作成します。
    
      - **インデックス名**: retail
    
      - **キー**: ID

1.  次の表を使用して、インデックスのフィールドを構成します：

| **フィールド**        | **種類**   | **取得可能** | **フィルター可能** | **並べ替え可能** | **ファセット可能** | **検索可能** | **アナライザー**          |
| ---------------- | ---------- | --------------- | -------------- | ------------ | ------------- | -------------- | --------------------- |
| **ID**           | Edm.String | **✓**           |                | **✓**        |               |                |                       |
| **名前**         | Edm.String | **✓**           |                | **✓**        |               | **✓**          | **Standard - Lucene** |
| **価格**        | Edm.Double | **✓**           | **✓**          | **✓**        | **✓**         |                |                       |
| **数量**     | Edm.Int32  | **✓**           | **✓**          | **✓**        | **✓**         |                |                       |
| **製造業者** | Edm.String | **✓**           | **✓**          | **✓**        | **✓**         |                |                       |

#### 復習

この演習では、新しい Azure Search アカウントを作成し、アカウント内にインデックスを作成しました。

### エクササイズ 2: Azure 検索で Azure Storage テーブルのインデックスを作成する

#### タスク 1: Azure Storage  アカウントを作成する

1.  Azureポータルから、以下の詳細を使用して新しい**ストレージ アカウント**を作成します。
    
      - **既存のリソース グループ**: MultiTierService
    
      - **名前**: prodstorage\[小文字で名前を指定\]
    
      - **場所**: (US) 米国東部
    
      - **パフォーマンス**: Standard
    
      - **アカウントの種類**: StorageV2 (汎用 v2)
    
      - **レプリケーション**: 読み取りアクセス ゲオ冗長ストレージ (RA-GRS)
    
      - **アクセス階層**：ホット

        > **注意**: Azure が Storage アカウントの作成を完了するのを待ってから、ラボを進みます。アカウントの作成時に通知が届きます。

1.  新しく作成した**ストレージ アカウント インスタンス**の**アクセス キー**ブレードにアクセスします。

1.  **接続文字列**フィールドの値を記録します。これらの値は、この演習の後半で使用します。

#### タスク 2: Azure Storage にテーブルエンティティをアップロードする

1.  この実習ラボで前述した **prodstorage\** ストレージ アカウントにアクセスします。

1.  **テーブル サービス** セクションで、 **テーブル** リンクを選択します。

1.  以下の設定で新しい**テーブル**を作成します。
    
      - **名前**: 製品

1.  ブレードの **概要** セクションで、**エクスプローラで開く**  を選択して、 **Azure Storage Explorer** を使用して Storage アカウントを開きます。

1.  このラボで前に作成した **prodstorage\** Storage アカウントに表示される A**Azure Storage Explorer** アプリケーションで、 **製品**テーブルを見つけて開きます。

1.  **製品テーブル**  タブで、ラボ マシンの **すべてのファイル (F):\\Allfiles\\Labs\\06\\Starter**フォルダにある **products.csv** をインポートし、 **インポートする**を選択します。

#### タスク 3: Azure Search インデクサーの作成

1.  この実習ラボで前に作成した **prodsearch\** 検索サービスにアクセスします。

1.  **検索サービス** ブレードで、**データのインポート**を選択 します。

1.  **インポートデータ**ブレードで、以下の詳細を含む新しいインデクサーを作成します。
    
    - **データ ソース**Azure テーブルストレージ

    - **データ ソース名**: tabledatasource

    - **接続文字列**: \<* このラボで前に作成した **prodstorage\** ストレージ アカウントを選択します。 \>*

    - **テーブル名**: 製品

    - **インデックス名**: 製品

    - **キー**: RowKey

    - 次の表を使用して、インデックスのフィールドを構成します：

        | **フィールド**    | **種類**   | **取得可能** | **フィルター可能** | **並べ替え可能** | **ファセット可能** | **検索可能** | **アナライザー**          |
        | ------------ | ---------- | --------------- | -------------- | ------------ | ------------- | -------------- | --------------------- |
        | **キー**      | Edm.String | **✓**           |                | **✓**        |               |                |                       |
        | **名前**     | Edm.String | **✓**           |                | **✓**        |               | **✓**          | **Standard - Lucene** |
        | **価格**    | Edm.Double | **✓**           | **✓**          | **✓**        | **✓**         |                |                       |
        | **数量** | Edm.Int32  | **✓**           | **✓**          | **✓**        | **✓**         |                |                       |

    - **インデクサー 名**: tableindexer

    - **スケジューラ**: ユーザー設定

    - **間隔**: 5
    
    - **開始時刻**: *今日の日付の午前 0 時 (UTC)*

        > **注意**: [**送信**] ボタンを表示するには、[**削除のトレース**] フィールドと [**1 回/カスタム**] オプションを選択してオフにする必要がある場合があります。これは、ポータルのバグが原因です。

1.  この実習ラボで作成した**テーブルインデクサー**インデクサーを手動で**実行**します。

1.  **テーブルインデクサー**インデクサーのメタデータとその最新の実行を観察します。メタデータには、ドキュメント数や最後のインデックス作成操作の状態などの情報が含まれます。最後のインデックス作成操作が成功し、複数のドキュメントがインデックスに追加されたことを確認してください。

#### タスク 4: インデックス化した表データを確認します

1.  この実習ラボで前に作成した **prodsearch\** 検索サービスの **Search Explorer** を開きます。

1.  すべてのフィールドを既定の (空の) 値に設定したままにして、**Enter** を選択して、空のクエリを実行します。このクエリの結果は、インデックス内のすべてのドキュメントの結果のページを返します。

1.  以下のクエリを実行して結果を見ます：


    ```
    search=seat
    ```

1.  以下のクエリを実行して結果を見ます：


    ```
    $filter=price lt 100
    ```

1.  以下のクエリを実行して結果を見ます：


    ```
    facet=quantity,interval:25
    ```

1.  以下のクエリを実行して結果を見ます：


    ```
    $filter=quantity gt 25&facet=price,values:100|1000|10000
    ```

#### タスク 5: Azure Search ベース URL を取得する

1.  この実習ラボで前に作成した **prodsearch\** 検索サービスにアクセスします。

1.  **検索サービス** ブレードで、**URL** フィールドの値をコピーします。これらの値は、この演習の後半で使用します。

#### 復習

この演習では、Azure Storage アカウントを作成し、Azure Search を使用してアカウント内のストレージ テーブルにインデックスを作成しました。表がインデックス化された後、Storage 表のエンティティ―のコピーに対して検索クエリを発行することができました。

### エクササイズ 3: Azure API Management を使って、ＡＰＩ プロクシー層を構築

#### タスク 1: 新しい API の定義

1.  この実習ラボで前述した **prodapi\** API Management アカウントにアクセスします。

1.  新しいアカウントの **API** の一覧を表示します。

> **注記**：すべての新しいアカウントは、単純な **エコー API** で始まります。

1.  以下の詳細を使用して新しい **Blank API** を作成します。
    
    - **表示名**: 検索 API

    - **名前**: search-api

    - **Web サービスの URL**: この実習ラボで前にコピーした **検索サービス URL** を入力します。**Web サービス URL** フィールドの値を次の相対 URL で追加します。

        ```
        /indexes/products/docs
        ```

        > **注意**: たとえば、Web サービスの URL が https://prodsearchstudent.search.windows.net 場合、新しい URL は https://prodsearchstudent.search.windows.net/indexes/products/docs になります。

    - **API URL サフィックス**: search

    - **製品**: **スターター** オプションと **無制限** オプションの両方を選択します。

1.  最近作成した API に新しい**操作**を追加し、次の詳細を追加します。
    
      - **表示名**: 全てのドキュメントの一覧
    
      - **名前**: list-all-documents
    
      - **URL**: GET /

1.  次の詳細を含む新しい **セット ヘッダー** の受信ポリシーを **すべての操作**に追加します。
    
      - **名前**: api-key
    
      - **値**: この実習ラボで前に記録した Search Service キーの値を入力します。

1.  次の詳細を含む新しい**クエリ パラメータの設定** インバウンド ポリシーを **すべての操作**に追加します。
    
      - **名前**: api-version
    
      - **値**: 2017/11/11
    
      - **アクション**: override

1.  次の詳細を含む**すべてのドキュメントの一覧**操作にスコープを設定した新しい **クエリ パラメータの設定**  インバウンド ポリシーを追加します。
    
      - **名前**: search
    
      - **値**: *\**
    
      - **アクション**: override

1.  API 要求の結果を確認して、 **検索 API** で **すべてのドキュメントの一覧**操作をテストします。

    > **注記**：応答に大量の Azure Search メタデータがあることを確認します。API ユーザーに、バックグラウンドで発生する実装の詳細を見られたくない場合があります。次のタスクでは、このデータの大部分を難読化します。

#### タスク 2: API 応答の操作

1.  次の詳細を含む新しい **セット ヘッダー** アウトバウンド ポリシーを **すべての操作**に追加します。
    
    1.  **名前**: preference-applied
    
    1.  **アクション**: delete

1.  次の詳細を含む新しい **セット ヘッダー** アウトバウンド ポリシーを **すべての操作**に追加します。
    
    1.  **名前**: odata-version
    
    1.  **アクション**: delete

1.  次の詳細を含む新しい **セット ヘッダー** アウトバウンド ポリシーを **すべての操作**に追加します。
    
    1.  **名前**: powered-by
    
    1.  **値**: Contoso
    
    1.  **アクション**: override

1.  XML コンテンツの次のブロックを最初に見つけることで、 **すべてのドキュメントの一覧 **操作にスコープが設定された新しいカスタム送信ポリシーを追加します。


    ```
    <outbound>
        <base />
    </outbound>
    ```

次に、その XML ブロックを次の XML に置き換えます。
    
    ```
    <outbound>
        <base />
        <set-body>
        @{ 
            var response = context.Response.Body.As<JObject>();
            return response.Property("value").Value.ToString();
        }
        </set-body>
    </outbound>
    ```

1.  API要求の結果を確認する**検索 API** で **すべてのドキュメントの一覧**操作をテストします。

    > **注記**：**指定したプリファレンス適用** ヘッダーと **odata バージョン** ヘッダーが削除され、新しい**電源付き**ヘッダーに置き換えられていることがわかります。また、応答には OData 応答に関するコンテキスト データが含まれておらず、応答本文としてフラット化された JSON 配列が含まれていることも確認してください。

#### 復習

この演習では、Azure Search アカウントと検索クエリを実行する開発者の間にプロキシ階層を構築しました。

### エクササイズ 4: Azure Logic Apps を使用して新しいテーブル エンティティを作成する

#### タスク 1: Logic アプリ リソースの作成

1. Azureポータルから、以下の詳細を使用して新しい**ロジックアプリ**を作成します。
    
    - **既存のリソース グループ**: MultiTierService

    - **名前**: prodworkflow\[小文字で名前を指定\]

    - **場所**: 米国東部

    - **ログ分析**オフ

        > **注意**: Azure が Logic Apps リソースの作成を完了するのを待ってから、ラボを進めます。リソースの作成時に通知が届きます。

#### タスク 2: Logic アプリのワークフロー用トリガーの作成

1.  **ロジック アプリ デザイナ** ブレードで、 **空白のロジック アプリ**テンプレートを選択します。

1.  **デザイナ**  領域で、次のサンプル JSON ドキュメントを使用して JSON スキーマを生成することにより、 **HTTP 要求を受信したとき**に新しいトリガーを追加します。


    ```
    { 
        "id": "",
        "manufacturer": "",
        "price": 0.00,
        "quantity": 0,
        "name": ""
    }
    ```

#### タスク 3: Azure Storage 用コネクターの構築

1. **デザイナ** 領域に、次の詳細を含む新しい "**挿入または置換エンティティ"**アクションを追加します。

    - **接続名**：テーブル接続

    - **ストレージ アカウント**\<このラボで前に作成した **prodstorage\** ストレージ アカウントを選択します。

    - **テーブル**: 製品

    - **パーティション キー**: 製造者 (動的フィールド - HTTP 要求を受信したとき)

    - **RowKey**: id (動的フィールド - HTTP 要求を受信したとき)

    - **エンティティ**: 本文 (動的フィールド - HTTP 要求を受信したとき)

#### タスク 4: HTTP 応答アクションの構築

1. **デザイナ** 領域に、次の詳細を含む新しい**応答アクション**を追加します。
    
    - **状態コード**: 201
    
    - **本文**: 本文 (動的フィールド - エンティティの挿入または置換)

#### タスク 5: HTTP トリガー POST URL の取得

1.  **デザイナ**領域で、**保存**を選択します。

1.  ワークフローが保存されると、 **HTTP 要求を受信した場合**の ** HTTP POST URL** フィールドが新しい URL で更新され、このワークフローを開始する必要があります。**HTTP POST URL** フィールドに URL をコピー します。この URL は、ラボにて後で使用します。

    > **注記**：SAS トークンを持った URL を含むため、これは非常に長い URL となります。確実に URL 全体をコピーしてください。

#### タスク 6: ロジック アプリの結果がインデックス化されていることを確認してください。

1.  新しい Azure Cloud Shell インスタンスを開きます。

1.  **クラウドシェル**がまだ構成されていない場合は、既定の設定を使用して Bash のシェルを構成します。

1.  Cloud Shell コマンド プロンプト内で、次の部分的な **CURL** コマンドを入力して、Logic Apps インスタンスに **HTTP POST** 要求を発行し、Enter キーを押します。


    ```
    curl \
    --header "Content-Type: application/json" \
    --data '{"id":"6","manufacturer":"VEHTOP","price":750,"quantity":6,"name":"car roof rack"}' \
    ```

1.  次に、この実習ラボで前にコピーしたロジック アプリ*の* **HTTP POST URL** を入力して、URL 文字がエスケープされないように **引用符**  で囲みます。**Enter** キーを押してコマンドを実行します。

    > **注記**：たとえば、URL が https://prod.eastus.logic.azure.com:443/workflows/test/triggers/invoke?api-version=2016\&sig=3の場合、"https://prod.eastus.logic.azure.com:443/workflows/test/triggers/manual?invoke?api-version=2016\&sig=3"を挿入します。引用符を含めないと、SAS トークンが切り捨てられ、要求を発行する必要があることを示すエラー メッセージが表示されます。これは、クエリ文字列区切り記号 **&** が引用符で囲まれていない場合に切り捨てられるために発生します。

1.  この実習ラボで前に作成した **prodsearch\** 検索サービスにアクセスします。

1.  この実習ラボで作成した**テーブルインデクサー**インデクサーを手動で**実行**します。

1.  この実習ラボで前に作成した **prodsearch\** 検索サービスの **Search Explorer** を開きます。

1.  空のクエリを実行して結果を見ます。

    > **注記**：この時点で、ロジックアプリによって挿入された新しいドキュメントを表すインデックス内の 6 番目のドキュメントが表示されます。

1.  この実習ラボで前述した **prodapi\** API Management アカウントにアクセスします。

1.  API 要求の結果を確認して、 **検索 API** で **すべてのドキュメントの一覧**操作をテストします。

    > **注記**：現在、5つではなく6つのドキュメントがあることに注意してください。

#### 復習

この演習では、HTTP 要求を受け取り、要求の JSON 本体を新しい Azure Storage テーブル エンティティとして保持するロジックアプリを作成しました。

### エクササイズ 5: サブスクリプションのクリーンアップ 

#### タスク 1: Cloud Shell を開く

1.  ポータルの上部で、**Cloud Shell** アイコンを選択して新しいシェル インスタンスを開きます。

1.  ポータルの下部にある **Cloud Shell**コマンド プロンプトで、次のコマンドを入力し、Enter キーを押してサブスクリプション内のすべてのリソース グループを一覧表示します。


    ```
    az group list
    ```

1.  次のコマンドを入力し、Enter キーを押して、リソース グループを削除する可能性のあるコマンドの一覧を表示します。


    ```
    az group delete --help
    ```

#### タスク 2: リソース グループを削除する

1.  次のコマンドを入力し、Enter キーを押して **MultiTierService** リソース グループを削除します。


    ```
    az group delete --name MultiTierService --no-wait --yes
    ```

1.  ポータルの下部にある **Cloud Shell** ペインを閉じます。

#### タスク 3: アクティブなアプリケーションを閉じる

1.  現在実行中の **Microsoft Edge** アプリケーションを閉じます。

1.  今実行している **Microsoft Azure Storage Explorer** アプリケーションを閉じます。

#### 復習

この実習では、この演習で使用する **リソース グループ** を削除してサブスクリプションをクリーンアップしました。
